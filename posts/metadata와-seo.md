<h2 data-ke-size="size26">metadata와 SEO</h2>
<h3 data-ke-size="size23">SSR vs CSR</h3>
<p data-ke-size="size16">웹 페이지의 제목과 내용을 담는 데이터이다.</p>
<p data-ke-size="size16">Next.js에서는 객체 형태로 담고 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">구글이나 네이버 같은 검색 엔진은 우리의 페이지가 어떤 페이지인지 모르고, 웹 사이트의 코드를 통째로 읽어서 판단하는 것도 아니며, 이 metadata를 우선적으로 읽는다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그런데 React.js는 CSR 방식이라 검색 엔진에 최적화하는 데 한계가 있었다.</p>
<p data-ke-size="size16">리액트의 동작 방식을 보면, 초기 HTML은 root의 div 하나가 통으로 빈 상태로 클라이언트에게 전달이 되고, 웹사이트 구동에 필요한 JS 등이 하나의 덩어리로 번들링 되어 클라이언트에게 전달된다.</p>
<p data-ke-size="size16">이렇게 하기 때문에 초반에 불러오는 속도는 느리다. 즉 Time To View가 느리다. 하지만 일단 클라이언트에서 렌더링 되고 나서는 타의 추종을 불허하는 속도로 쾌적함을 선사한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">하지만 초기에 빈 div를 던지는 방식의 특성 상 검색 엔진이 웹 사이트를 제대로 인덱싱 할 수 없다.</p>
<p data-ke-size="size16">따라서 검색 엔진에 잘 노출이 되어야 하는 비즈니스 웹 사이트는 검색엔진 최적화(SEO)에서 리액트는 불리하다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">반면 Next.js는 SSR 방식으로, 첫 로딩 시 이미 서버에서 HTML을 렌더링 해서 클라이언트에 전달하기 때문에 초기 로딩 속도가 빠르다. 하지만 이후 웹 사이트를 이용하며 전환할 때 리액트 대비 속도는 늦을 수 있고,</p>
<p data-ke-size="size16">리액트에서는 클라이언트가 렌더링 했던 것을 넥스트에서는 서버에서 렌더링 하기 때문에 서버 부하가 상대적으로 높을 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">리액트에서도 SEO 최적화를 하기 위한 여러 기법이 있지만, SEO가 중요한 사이트를 제작하는 경우 넥스트가 더 나은 선택이다.</p>
<h2 data-ke-size="size26">Next.js의 Metadata</h2>
<pre id="code_1719852923788" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>// src/app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
<p>const inter = Inter({ subsets: [&quot;latin&quot;] });</p>
<p>export const metadata: Metadata = {
title: &quot;Create Next App&quot;,
description: &quot;Generated by create next app&quot;,
};</p>
<p>export default function RootLayout({
children,
}: Readonly&lt;{
children: React.ReactNode;
}&gt;) {
return (
&lt;html lang=&quot;en&quot;&gt;
&lt;body className={inter.className}&gt;{children}&lt;/body&gt;
&lt;/html&gt;
);
}</code></pre></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">layout.tsx 파일 안에 metadata가 객체 형태로 title과 description 형태로 기본 세팅되어 있다.</p>
<p data-ke-size="size16">여기서 눈치 챌 수 있듯, 라우트마다 전부 다른 메타데이터를 생성할 수 있다.</p>
<pre id="code_1719853114147" class="typescript" data-ke-language="typescript" data-ke-type="codeblock"><code>import React from "react";
<p>type Props = {
params: {
id: string;
};
};</p>
<p>export function generateMetadata({ params }: Props) {
return {
title: <code>Detail 페이지 : ${params.id}</code>,
description: <code>Detail 페이지 : ${params.id}</code>,
};
}</p>
<p>const TestDetailPage = ({ params }: Props) =&gt; {
return &lt;div&gt;Detail 페이지 : {params.id}&lt;/div&gt;;
};</p>
<p>export default TestDetailPage;</code></pre></p>
<p data-ke-size="size16">danymic route에서도 동적으로 변경되는 params를 이용해서 metadata를 라우트마다 설정해줄 수도 있다.</p>
<h2 data-ke-size="size26">SEO 최적화 팁</h2>
<p data-ke-size="size16">주로 HTML, JSX와 관련된 태그를 성실하게 작성하는 데서 출발한다.</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>meta title : 위에서 설명했다.</li>
<li>meta description : 위에서 설명했다.</li>
<li>meta keyword : 과거엔 많이 사용됐으나, 현재는 대부분의 검색엔진에서 무시한다. 하지만 알고는 있자.</li>
<li>헤딩 태그 : &lt;h1&gt;을 글씨 크기로 사용하면 곤란하다. 제목의 deps를 나타내는 것이 주 기능이므로 페이지에서 h1 태그를 남발해서는 안 되고, 구조화가 잘 되도록 h1~h6 잘 이용하도록 한다. 특히 h1 태그는 페이지에서 한 번만 사용하고 제일 중요한 제목에만 사용해야 한다.</li>
<li>이미지 대체 텍스트 : &lt;img alt="..."&gt; 이 이미지가 어떤 이미지인지 검색 엔진은 볼 수 없으므로, alt 속성으로 이미지를 판단한다. 옵셔널한 속성이기 때문에 귀찮다고 빼 먹으면 좋지 못한 습관이다.</li>
<li>Anchor Text : 링크 텍스트를 말한다. &lt;a href="https://wonyoung.com"&gt;클릭&lt;/a&gt; 이런 단순한 메시지는 무슨 링크인지 모르기 때문에 구체적인 텍스트를 작성해야 한다.</li>
</ul>